\*\* 자바스크립트로 만든 앱을 리액트로 변경  
\*\* 실습은 클래스형으로 진행한다

## 💡요구사항

### 검색폼

1. 검색 상품명을 입력할 수 있는 폼이 위치한다
2. 검색어를 입력하면 x버튼이 보이고 검색어를 삭제하면 x 버튼을 숨긴다
3. 엔터를 입력하면 검색 결과가 보인다(컨트롤러에게 위임)
4. x버튼을 클릭하거나, 검색어를 삭제하면 검색 결과를 삭제한다

### 검색결과

1. 검색 결과가 검색폼 아래 위치한다. 검색 결과가 없을 경우와 있을 경우를 구분한다
2. x버튼을 클릭하면 검색폼이 초기화되고, 검색 결과가 사라진다

### 탭

1. 추천 검색어, 최근 검색어 탭이 검색폼 아래 위치한다
2. 기본으로 추천 검색어 탭을 선택한다
3. 각 탭을 클릭하면 탭 아래 내용이 변경된다

### 추천 검색어

1. 번호와 추천 검색어 이름이 목록 형태로 탭 아래 위치한다
2. 목록에서 검색어를 클릭하면 선택된 검색어의 검색 결과 화면으로 이동한다

### 최근 검색어

1. 최근 검색어 이름, 검색 일자, 삭제 버튼이 목록 형태로 탭 아래 위치한다
2. 목록에서 검색어를 클릭하면 선택된 검색어로 검색 결과 화면으로 이동한다
3. 목록에서 x버튼을 클릭하면 선택된 검색어가 목록에서 삭제된다
4. 검색시마다 최근 검색어 목록에 추가된다

<br />

## 💡정리

### 리액트의 동작 원리 이해

```jsx
const state = { _data: "hello world" };
// dom 엘리먼트 생성
const h1 = document.createElement("h1");
document.body.appendChild(h1);

const render = () => (h1.textContent = state._data);

// 객체에 새로운 속성을 직접 정의하거나 속성을 수정한 후, 해당 객체를 반환
Object.defineProperty(state, "data", {
  get() {
    return state._data;
  },
  set(value) {
    state._data = value;
    // 객체가 수정되면 화면이 바뀔 수 있도록 한다
    render();
  },
});

render();

setTimeout(() => {
  state.data = "안녕하세요";
}, 2000);
```

- 데이터만 제어하면 자동으로 화면에 반영
- 이렇게 특정 값에 의존해 자동으로 반응하는 것을 **리액티브하다** 라고 표현한다
- 값이 변경될 때마다 화면이 렌더링된다면 DOM API호출로 인해 브라우저 성능에 영향을 미칠 수 있다.
- 따라서 실제돔이 아닌 가상돔을 활용해 렌더링을 줄여 브라우저 성능을 향상시키는 것이 리액트의 개념이다
- 리액트는 애플리케이션의 화면 변경을 돔에게 직접 요청하는 것이 아니라 가상돔에게 요청하고, 전체 가상돔과 이전 가상돔의 차이를 찾아 변화된 부분만 실제 돔에 반영하는 방식으로 성능을 높인다

### 리액트 개념

- DOM에 엘리먼트가 있듯 리액트에서 엘리먼트 개념이 있으며 이것이 리액트 앱을 구성하는 최소 단위다.

  ```jsx
  React.createElement("h1", null, "Hello World");
  ```

- 리액트가 만든 가상돔은 일반 객체로 이루어져 있다. 이는 렌더링하는 환경에 상관없이 다양한 플랫폼에서 동작할 수 있게 해주는데 이것이 바로 ReactDOM라이브러리이다. 리액트는 react + reactDOM 라이브러리를 사용하는 것이다.

  ```jsx
  ReactDOM.render(element, document.querySelector("#app"));
  ```

- 엘리먼트 생성시 함수만으로도 가능하지만 문제는 UI를 나타내는 코드를 읽기 어렵다는 것이다. 따라서 리액트에서는 JSX라는 자바스크립트 확장 문법을 사용한다.
- 리액트는 **컴포넌트**라고 불리는 고립된 코드의 파편을 이용해 복잡한 UI를 구성하도록 돕는다

<br/>

## ✅ 핵심

### 리스트 key 사용

- Key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해줘야 한다.
- 가상돔은 트리를 비교해야 하기 때문에 O(n^3)만큼의 계산 복잡도를 가지는데 이러한 계산은 오히려 화면 렌더링을 느리게 만들 수도 있다
- 따라서 두 가지 가정하에 재조정 알고리즘을 사용한다
  - 엘리먼트 타입이 다를 경우
  - Key값이 다를 경우
- 각 각 경우에 따라 화면을 조정하는데 이 때 복잡도는 O(n)으로 줄어들게 된다.
- 따라서 li를 여러 개 사용하게 되면 엘리먼트 타입이 아닌 key로 차이를 판단해줘야 하므로 key속성을 사용해야 한다
  ```jsx
  <li key={item.id}>
  ```

### 리액트 라이프 사이클

- 리액트 컴포넌트는 생성부터 소멸까지 일련의 생명 주기를 갖는다.
- constructor: 컴포넌트 상태 등 초기화 작업을 완료하면 컴포넌트 객체가 생성된다.
- render: 리액트 엘리먼트를 이용해 가상돔을 실제 돔에 반영한다.
- componentDidMount: 돔에 반영되는 것을 마운트된다고 하는데 마운트가 완료되면 이벤트를 바인딩하거나 외부 데이터를 가져오는 등의 작업을 수행한다.
- compoentWillUnmount: 컴포넌트가 사라지기 전(마운트 직전)에 이벤트 핸들러를 제거하는 등 리소스 정리 작업을 한다
- 마지막으로 컴포넌트는 본인의 삶을 마감한다

### 버블링 현상

```jsx
<li onClick={() => this.search(keyword)}>
  <button onClick={() => this.handleClickRemoveHistory(keyword)} />
</li>
```

- 위 코드에서 처럼 button을 클릭하면 `handleClickRemoveHistory()`메서드 실행과 함께 `li`의 `search()`가 함께 실행된다
- 자식에서 발생한 이벤트가 부모까지 버블링 되어 올라가 버블링 현상이라 한다.
- 이러한 이벤트 버블링 현상을 차단하기 위해서는 자식 메서드에 이벤트 객체의 `stopPropagation()`를 사용해 이벤트 전파를 방지한다.

### 자바스크립트와 리액트 비교

- 자바스크립트는 모델, 뷰가 서로 독립적으로 각자의 역할을 수행하였다.
- 컨트롤러가 이 둘을 관리하며 애플리케이션 상태와 이에 따른 UI를 수시로 변화시킨다.
- 리액트는 모델이 스토리지만 가지고 있고, 상태는 컴포넌트로 위임한다.
- 컴포넌트의 state로 관리되는 상태는 render() 함수가 반환하는 리액트 엘리먼트와 유기적으로 연결되어 화면에 출력된다.
- 돔 앞단에 가상돔 계층을 추가해 수시로 변경 요청을 받은 가상돔은 최소한의 돔 API만을 사용해 화면을 효율적으로 렌더링한다.
